using UnityEngine;
using System.Collections;
using System.Text;
using System.IO;
using System.Collections.Generic;



[ExecuteInEditMode]
//[RequireComponent(typeof(MeshFilter))]
//[RequireComponent(typeof(MeshRenderer))]
//[RequireComponent(typeof(BoxCollider))]



	public class Map : MonoBehaviour {
	public bool test = false;
	public int size_x;
	public int size_z;
	public float border;    //+ for space above map, - for space below map
	public float tileSize = 1.0f;
	string title;
	private bool oldmap = false;
	public char[,] map;
	public char[,] GRID;
	public char[,] visibleGRID;
	private string level;

	bool waypoint = false;
	public Vector3 invalid = new Vector3 (999, 999, 999);
	float x_center;
	float z_center;

	List<JSONObject> props = new List<JSONObject>();
	Queue<string> file;
	//public StreamReader me;
	Vector3[] vertices;
	int[] triangles;
	Vector3[] normals;
	Vector2[] uv;
	int layerMask = 1 << 11;
	GameObject myGrid;
	GameObject wallBack;
	GameObject wallFront;
	GameObject wallLeft;
	GameObject wallRight;
	Quaternion frontAngle = Quaternion.Euler (90, 0, 0);
	Quaternion backAngle = Quaternion.Euler (270, 0, 0);
	Quaternion leftAngle = Quaternion.Euler (270, 0, -90);
	Quaternion rightAngle = Quaternion.Euler (270, 0, 90);
	Dictionary<char,subMesh> subs = new Dictionary<char, subMesh>();
	Dictionary<char,subMesh> grid = new Dictionary<char, subMesh>();
	Dictionary<char,subMesh> wall = new Dictionary<char, subMesh>();
	Vector3 backPosition;
	Vector3 rightPosition;
	Vector3 frontPosition;
	Vector3 leftPosition;
	Mesh mesh;
	Dictionary<int, char> subkey = new Dictionary<int, char>(); //int to char
	public Material[] mat;

	public static Map Instance { get; private set; }


	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	AWAKE      
	void Awake(){
		Instance = this;
	//	Debug.Log ("Started map");

	}



    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              LOAD
	public void Load (string l) {
		reset();
		level = l;
		file = new Queue<string> (((TextAsset)Resources.Load ("Levels/" + l)).text.Split ('\n'));
	//	 me = new StreamReader ("Assets/Resources/Levels/"+l +".txt", Encoding.Default);

		GameObject parent = GameObject.Find ("Level");
		this.transform.parent = parent.transform;
		LoadFile ();



		BuildMesh (this.gameObject, subs, size_x, size_z,0,false);
		makeSubMeshes (this.gameObject, subs, map);
		myGrid = (GameObject)Instantiate (Resources.Load ("Core/Mapgrid"));

		myGrid.transform.parent = this.gameObject.transform;
		BuildMesh (myGrid.gameObject, grid, size_x, size_z,1,true);
		makeSubMeshes (myGrid.gameObject, grid, visibleGRID);

		Eyes.Instance.CalculateCamera ();

		/*
//////////////    BACK WALL
		wallBack = (GameObject)Instantiate (Resources.Load ("Core/Wall"));
	
		wallBack.transform.parent = this.gameObject.transform;
		BuildMesh (wallBack.gameObject, wall, size_x, size_z,3);
//		makeSubMeshes (wallBack.gameObject, subs, map);
//	
		Quaternion rotation = Quaternion.LookRotation (wallBack.transform.position);
		rotation *= backAngle;
		wallBack.transform.rotation = rotation;
		wallBack.transform.position = backPosition;

		
//		Debug.Log ("SIZE X " + size_x + " SIZE Z " + size_z);
//////////////    RIGHT WALL
		wallRight = (GameObject)Instantiate (Resources.Load ("Core/Wall"));
		wallRight.transform.parent = this.gameObject.transform;
		BuildMesh (wallRight.gameObject, wall, size_z, size_z,3);
	//	makeSubMeshes (wallRight.gameObject, subs, map);
		rotation = Quaternion.LookRotation (wallRight.transform.position);
		rotation *= rightAngle;
		wallRight.transform.rotation = rotation;
		wallRight.transform.localPosition = rightPosition;

		
		/////////////     LEFT WALL
		/// 
		wallLeft = (GameObject)Instantiate (Resources.Load ("Core/Wall"));
		wallLeft.transform.parent = this.gameObject.transform;
		BuildMesh (wallLeft.gameObject, wall, size_z, size_z,3);
	//	makeSubMeshes (wallLeft.gameObject, subs, map);
		rotation = Quaternion.LookRotation (wallLeft.transform.position);
		rotation *= leftAngle;
		wallLeft.transform.rotation = rotation;
		wallLeft.transform.localPosition = leftPosition;


//////////////    FRONT WALL
		wallFront = (GameObject)Instantiate (Resources.Load ("Core/Wall"));
		
		wallFront.transform.parent = this.gameObject.transform;
		BuildMesh (wallFront.gameObject, wall, size_x, size_z,3);
	//	makeSubMeshes (wallFront.gameObject, subs, map);
		
		 rotation = Quaternion.LookRotation (wallFront.transform.position);
		rotation *= frontAngle;
		wallFront.transform.rotation = rotation;
		wallFront.transform.localPosition = frontPosition;
*/
	}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              RESET
	public void reset(){
		GameObject[] props = GameObject.FindGameObjectsWithTag("Prop");

		foreach (GameObject junk in props){
			DestroyImmediate(junk);
			}
	}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              MAKE BLOCKED
	public void makeBlocked(int x, int z, char[,] matrix){
		matrix [x,z] = 'x';
	}

	public void makeBlocked(int x, int z){
		makeBlocked (x,z,GRID);
	}

	public void makeOpen(Vector2 m){
		GRID[(int)m.x, (int)m.y] = '.';
	}


	public void makeSelected(int x, int z){
		visibleGRID[x,z] = 's';
	//	Debug.Log("Selecting " + x + ", " + z + "\n");
	}

	public void makeX(int x, int z){
		map [x,z] = 'x';
	}


	public bool isX(int x, int z){
		return (map [x,z] == 'x');
	}

	public void makeX(Vector2 m){
		makeX ((int)m.x, (int)m.y);
		makeBlocked ((int)m.x, (int)m.y);
	}

	public void makeBlocked(Vector2 m, char[,] matrix){
		makeBlocked ((int)m.x, (int)m.y, matrix);
	}

	public void makeBlocked(Vector2 m){
		makeBlocked (m,GRID);
	}

	public void Toggle(int x, int z){
		if (GRID [x,z].Equals ('x')) {
			GRID [x,z] = '.';
		} else {
			GRID [x,z] = 'x';
		}
	}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              MAKE VISIBLE
	public void makeVisible(Vector2 m){
		visibleGRID = new char[GRID.GetLength (0), GRID.GetLength (1)];
		System.Array.Copy (GRID, visibleGRID, GRID.GetLength(0)*GRID.GetLength(1));
		visibleGRID [(int)m.x,(int)m.y] = 'x';
//		Debug.Log("Selecting " + (int)m.x + ", " + (int)m.y + "\n");
		//Debug.Log (getTile (m));
		makeSubMeshes (myGrid.gameObject, grid, visibleGRID);
		}


	public void makeVisible(Vector2 m, Vector3 scale){
		visibleGRID = new char[GRID.GetLength (0), GRID.GetLength (1)];
		System.Array.Copy (GRID, visibleGRID, GRID.GetLength(0)*GRID.GetLength(1));
		if (!isOpen((int)m.x, (int)m.y, (int)scale.x, (int)scale.z)){
			//Debug.Log("bad");
				return;
				}
		selectMe ((int)m.x, (int)m.y, (int)scale.x, (int)scale.z);

		//Debug.Log (getTile (m));
		foreach (Material hey in myGrid.GetComponent<MeshRenderer>().materials) {
			if (hey.name[0] == 's'){
				hey.mainTextureScale = new Vector2(size_x/scale.x, size_z/scale.z);
				hey.mainTextureOffset = new Vector2((scale.x -2- m.x%scale.x)/scale.x,(scale.z -2- m.y%scale.z)/scale.z); 
			}
		}
		makeSubMeshes (myGrid.gameObject, grid, visibleGRID);
	}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              LOAD FILE
	public  void LoadFile(){

				string line;
	//	Debug.Break ();
			line = file.Dequeue();
			line = line.TrimStart (':');
						line = line.TrimEnd ('\r', '\n');
						title = line;//first line is always the title
			line = file.Dequeue();
			
						int count = 0;
								line = line.TrimEnd ('\r', '\n');
				while (line != null && !line.Equals(":")){
						switch (line) {
								case ":map":				                    
									//	Debug.Log ("Loading Map!");
										if (oldmap){
											line = LoadMap();
				}else{	line = file.Dequeue();}	
				//	Debug.Log ("Done Loading Map! Line is " + line);
										break;
								case ":props":
									//	Debug.Log ("Loading Props!");
										line = LoadProps();
										break;
								case ":tiles":
									//	Debug.Log ("Loading Tiles!");
										line = LoadTiles();
										break;
								case ":toys":
									//	Debug.Log ("Loading Toys (Actors)!");
										if (!test){
											line = LoadActors("Toys");
				}else{	line = file.Dequeue();}	
				break;
								case ":monsters":
									//	Debug.Log ("Loading Monsters (Actors)!");
										if (!test){
											line = LoadActors("Monsters");
				}else{	line = file.Dequeue();}			
				break;
								case ":waves":
									//	Debug.Log ("Loading Monsters (Actors)!");
				if (!test){line = LoadWaves();}else{	line =file.Dequeue();}	
				break;
								case ":init_stats":
										line = LoadStats();
										break;
								case ":camera_stats":
										line = LoadCamera(line);
										break;
								case ":":
									//	Debug.Log ("Done Loading File!");
										break;
								default:
									//	Debug.Log ("Skipping line: " + line);
				line = file.Dequeue();
				break;
						
							}
						line = line.TrimEnd ('\r', '\n');
			}
							count++;
						


	}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	LOAD STATS
	
	public string LoadStats(){
		string line = file.Dequeue();
		while (line != null && !line[0].Equals (':')) {
			
			JSONParser p = new JSONParser (line);
			p.parse ();
			JSONObject dreams = new JSONObject ();
			JSONObject max_dreams = new JSONObject ();
			JSONObject s = new JSONObject ();
			JSONObject type = new JSONObject ();
			JSONObject points = new JSONObject ();
			JSONObject pathf = new JSONObject ();
			p.root.TryGetValue ("dreams", out dreams);
			p.root.TryGetValue ("points", out points);
			p.root.TryGetValue ("max_dreams", out max_dreams);
			p.root.TryGetValue ("size", out s);
			p.root.TryGetValue ("pathf", out pathf);
			p.root.TryGetValue ("type", out type);
			Peripheral.Instance.dreams = int.Parse(dreams.value);
			Peripheral.Instance.max_dreams = int.Parse(max_dreams.value);
			Vector3 size = Central.Instance.Vector2D(s);
			size_x = (int)size.x;
			size_z = (int)size.z;
			PathfinderType PathType = PathfinderType.GridBased;
			Central.Instance.points = int.Parse(points.value);
			if (type != null && type.value.Equals("old")){
				oldmap = true;
			}else{
				LoadBasicMap();
			}
			if (pathf.value.Equals("waypoint")){
				//		Debug.Log("waypoint based level");
				PathType  = PathfinderType.WaypointBased;
				LoadWayPointMap();
				waypoint = true;
			}

		

			Peripheral.Instance.pathf = PathType;
			line = file.Dequeue();
			
		}
		return line;
		
	}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	LOAD CAMERA STATS
	

	void LoadBasicMap(){
				map = new char[size_x, size_z];
				GRID = new char[size_x, size_z];
				for (int x = 0; x < size_x; x++) {
						for (int z = 0; z < size_z; z++) {
								map [x, z] = '.';
								GRID [x, z] = '.';
						}
				}
	//	Debug.Log ("Setting x_center to " + x_center);
				x_center = (float)size_x * tileSize / 2.0f;
				z_center = size_z * tileSize / 2;
				visibleGRID = new char[GRID.GetLength (0), GRID.GetLength (1)];
				System.Array.Copy (GRID, visibleGRID, GRID.GetLength (0) * GRID.GetLength (1));
			
				backPosition = new Vector3 (0, tileSize * size_z / 2f, tileSize * size_z / 2f);
				rightPosition = new Vector3 (tileSize * size_x / 2f, tileSize * size_z / 2f, (size_z - size_x) * tileSize / 2f);
				frontPosition = new Vector3 (0, tileSize * size_z / 2f, -tileSize * size_z / 2f);
				leftPosition = new Vector3 (-tileSize * size_x / 2f, tileSize * size_z / 2f, -(size_z - size_x) * tileSize / 2f);
				if (!test) {
						Eyes.Instance.PlaceCamera (size_x, size_z, tileSize);
				}
		}
	void LoadWayPointMap(){

			//string[] path = level.Split('\\');
			//string l = path[path.GetLength(0)-1];
			//string[] name = l.Split('.');
						GameObject waypath = (GameObject)Resources.Load ("Core/" + level + "_pathfinder");
			//Debug.Log ("Core/" + name[0] + "_pathfinder");

			

			List<WaypointNode> wps = new List<WaypointNode> (waypath.GetComponentsInChildren<WaypointNode> (true));
			wps.Sort (delegate(WaypointNode i1, WaypointNode i2) { 
				return i1.ID.CompareTo (i2.ID); 
			});
			foreach (WaypointNode w in wps) {
				w.transform.position = CenterofTile (w.transform.position);
				w.position = w.transform.position;
		        foreach (WaypointNode n in w.neighbors) {

						if (w.name.CompareTo(n.name) < 0 && w.transform.position != n.transform.position){
			//			Debug.Log(w.name + " " + n.name);
			//		Debug.Log("making path from " + w.transform.position + " to " + n.transform.position + "\n");
							makePath(w.transform.position, n.transform.position);							
						}
					}
				}
			PlaceEnd(waypath.GetComponent<WaypointPathfinder>().finish.transform.position);
		//ConnectTiles ();
		MakeLotsofTinyPathColliders ();
		BlockBitsOfTheMap ();
		PlaceIslands ();
			}
		

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	MAKE PATH
	void makePath(Vector3 from, Vector3 to){
	//	Debug.Log ("makePath from " + from + " to " + to + "\n");
		//Vector3 start = CenterofTile (from);
		//Vector3 end = CenterofTile (to);
		Vector3 start = from;
		Vector3 end = to;
	//	Debug.Log ("Start " + start + " " + getTile(CenterofTile(start)));
	//	Vector3 direction = ray.direction;
		Vector3 direction = (end - start).normalized;

		makeX (getTile(CenterofTile(start)));
		makeX (getTile(CenterofTile(end)));
		int hi = 0;
		Vector3 path = start;

		Vector2 path_tile = getTile (CenterofTile(start));
		Vector2 end_tile = getTile (CenterofTile(end));
		while (path_tile != end_tile && hi < 40) {
			Vector2 current_tile = getTile (path);
			path = path + direction * tileSize/Mathf.Sqrt(2);
			path_tile = getTile (path);
			//on a diagonal?
			/*
			if (current_tile.x != path_tile.x && current_tile.y != path_tile.y){
				Debug.Log("diagonal " + path_tile.x + " " + current_tile.y + "\n");
				makeX(new Vector3(path_tile.x, current_tile.y));
			}*/
			if (path.x > rightPosition.x || path.x < leftPosition.x || path.z > backPosition.z || path.z < frontPosition.z){
				path_tile = end_tile;
			}else{
				//got a tile
				makeX(getTile (path));
			}        
			hi++;
				}

		}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       		PLACE END

	//public Vector3 Bound


	public void PlaceEnd(Vector3 pos){
//		Debug.Log ("Placing end");
		GameObject End = (GameObject)Instantiate (Resources.Load ("Toys/End"));


		End.GetComponentInChildren<SphereCollider> ().radius = tileSize / 3f;
		End.transform.position = CenterofTile(pos);
		GameObject parent = GameObject.Find ("Level");
		End.transform.parent = parent.transform;
		End.GetComponentInChildren<Body> ().actor = Peripheral.Instance.gameObject;
		Peripheral.Instance.targets+= Peripheral.Instance.target_points;
	}

	
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	LOAD WAVES

	public string LoadWaves(){

//{"mode":"list","1":{"monster_invertal":"0.5", "lull_length":"3","list":{"forceball,5,scaleball,3"}},"2":{"monster_invertal":"1", "lull_length":"5","list":{"speedball,1,drunkenbox,10,forceball"}},"3":{"monster_invertal":"0.5", "lull_length":"3","list":{"forceball,1,bigslidingbox,3"}}}
//{"mode":"random","nightmares":"50","monsters":"drunkenbox","monster_interval":"1","lull_length":"5","wavelet_size":"5"}

		string line = file.Dequeue();
		while (line != null && !line[0].Equals (':')) {


			JSONParser p = new JSONParser (line);
		//	Debug.Log(line);
			p.parse ();

			JSONObject type = new JSONObject ();
			//	{"nightmares":"70","monsters":"zombie,buckyball"}
			JSONObject nm = new JSONObject ();
			JSONObject monster_interval = new JSONObject ();
			JSONObject lull_length = new JSONObject ();
			JSONObject wait_time = new JSONObject ();
			p.root.TryGetValue ("wait_time", out monster_interval);
			JSONObject mode = new JSONObject ();
			p.root.TryGetValue ("mode", out mode);

			switch (mode.value){
				case "random":
				JSONObject mon = new JSONObject ();			
				JSONObject mn = new JSONObject ();			
				p.root.TryGetValue ("interval", out monster_interval);

				p.root.TryGetValue ("lull", out lull_length);
				JSONObject wavelet_size = new JSONObject ();

				p.root.TryGetValue ("nightmares", out nm);
				p.root.TryGetValue ("monsters", out mon);

				p.root.TryGetValue ("wavelet_size", out wavelet_size);

				string[] monlist = (mon.value).Split (',');
				List<string> monsters = new List<string>();
		//		Debug.Log("Building a random wave\n");
				foreach(string a in monlist){
					monsters.Add(a);
				}


				wave hey = new wave (int.Parse (nm.value), monsters, 
			                     float.Parse (monster_interval.value), 
			                     float.Parse(lull_length.value), int.Parse(wavelet_size.value));
				if(wait_time.value != null){
					hey.wait = int.Parse(wait_time.value);
				}
				Peripheral.Instance.waves.Add (hey);
				break;
			case "list":
				//"1":{"monster_invertal":"0.5", "lull_length":"3","list":{"forceball,5,scaleball,3"}}
				JSONObject wavelet_num = new JSONObject ();
				JSONObject list = new JSONObject ();
				int i = 1;
				wave mywave = new wave();
				p.root.TryGetValue (i.ToString(), out wavelet_num);
				while(wavelet_num != null){
					monster_interval = wavelet_num.dict["interval"];
					lull_length = wavelet_num.dict["lull"];
					list = wavelet_num.dict["list"];
					string[] splitme = (list.value).Split (',');
					List<string> LIST = new List<string>();
					foreach(string a in splitme){
						LIST.Add(a);
					}
					wavelet hi = new wavelet(float.Parse(monster_interval.value), float.Parse(lull_length.value), LIST);
					mywave.add_wavelet(hi);
					i++;
					p.root.TryGetValue (i.ToString(), out wavelet_num);
				}

				if(wait_time.value != null){
					mywave.wait = int.Parse(wait_time.value);
				}
				Peripheral.Instance.waves.Add (mywave);

				break;
			default:
				break;
			}
				

			line = file.Dequeue();
		}

	


		return line;

	}





	public GameObject  PlaceObject (string name, string kind, Vector2 pos, Vector3 scaleV, bool blockspace){
		float xt, zt;
		xt = pos.x;
		zt = pos.y;

		Vector3 loc = new Vector3 (xt, 0, zt);
		
		if (xt > size_x || zt > size_z || xt < 0 || zt < 0) {
			//			Debug.Log ("SKIPPING row " + name.value + ", object will not be on the map, check position and scale!");
			return null;
		}else{
			Vector3 posv = invalid;
			posv = CenterofObject (xt, zt, scaleV.x, scaleV.z);
			GameObject thing = null;
			if (kind.Equals ("Toys")){
				thing = Peripheral.Instance.makeToy (name, posv);
			}else if (kind.Equals ("Monsters")){
				thing = Peripheral.Instance.makeMonster (name, new Vector3(0,0,0));
			}else{
				
				if (posv == invalid){
					//	Debug.Log("Trying to place " + name.value + " on an already occupied space. Skipping");
					return null;
				}
				thing = (GameObject)Instantiate (Resources.Load (kind + "/" + name));
				if (blockspace){
					blockMe((int)xt,(int) zt,(int) scaleV.x,(int) scaleV.z);
				}
				if (thing.GetComponentsInChildren<Light>() != null){
					foreach (Light light in thing.GetComponentsInChildren<Light>()){
						if (light.type == LightType.Spot){
							light.range = light.transform.position.z;
						}else if (light.type == LightType.Point){		
							light.range = light.range*scaleV.x+200;
						}
					}
				}
			}
			if (thing == null){
				return null;
			}
			
			GameObject parent = GameObject.Find (kind);
			thing.transform.parent = parent.transform;
			thing.transform.position = posv;
			thing.transform.localScale = scaleV;

			return thing;
		}
	}




	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	LOAD ON MAP
	public void LoadOnMap(string line, string kind){
				JSONParser p = new JSONParser (line);
				p.parse ();
				JSONObject name = new JSONObject ();
				JSONObject pos = new JSONObject ();
				JSONObject scale = new JSONObject ();
				float xt, zt;
				Vector3 scaleV;

				float x, z;
				JSONObject rotation = new JSONObject ();
				JSONObject wall = new JSONObject ();
				p.root.TryGetValue ("name", out name);
		//		Debug.Log ("Loading " + name.value + " " + kind);
				if (!p.root.TryGetValue ("pos", out pos)
						|| ! p.root.TryGetValue ("scale", out scale)) {
					//	Debug.Log ("SKIPPING " + name.value + ", object is missing pos, or scale.");

				} else {
			//Debug.Log (scale.dict ["x"].value);

						xt = float.Parse (pos.dict ["x"].value);
						zt = float.Parse (pos.dict ["z"].value);

						scaleV = Central.Instance.Vector2D(scale);
						Vector3 loc = new Vector3 (xt, 0, zt);

						if (xt > size_x || zt > size_z || xt < 0 || zt < 0) {
					//			Debug.Log ("SKIPPING row " + name.value + ", object will not be on the map, check position and scale!");
							
						}else{
						Vector3 posv = invalid;
						posv = CenterofObject (xt, zt, scaleV.x, scaleV.z);
						GameObject thing = null;
						if (kind.Equals ("Toys")){
							thing = Peripheral.Instance.makeToy (name.value, posv);
						}else if (kind.Equals ("Monsters")){
							thing = Peripheral.Instance.makeMonster (name.value, new Vector3(0,0,0));
						}else{

							if (posv == invalid){
							//	Debug.Log("Trying to place " + name.value + " on an already occupied space. Skipping");
								return;
							}
							thing = (GameObject)Instantiate (Resources.Load (kind + "/" + name.value));
							blockMe((int)xt,(int) zt,(int) scaleV.x,(int) scaleV.z);
							if (thing.GetComponentsInChildren<Light>() != null){
								foreach (Light light in thing.GetComponentsInChildren<Light>()){
									if (light.type == LightType.Spot){
											light.range = light.transform.position.z;
									}else if (light.type == LightType.Point){		
					//		Debug.Log('
											light.range = light.range*scaleV.x+200;
									}
								}
							}
						}
						if (thing == null){
							return;
						}

						GameObject parent = GameObject.Find (kind);
						thing.transform.parent = parent.transform;
						thing.transform.position = posv;
						thing.transform.localScale = scaleV;
						if (p.root.TryGetValue ("rotation", out rotation)) {
							thing.transform.Rotate (0, float.Parse (rotation.value), 0);
						}
						if (p.root.TryGetValue ("wall", out wall)) {
							if (wall.value.Equals("back")){
								Vector3 hey = new Vector3();
								hey = new Vector3(posv.x, posv.z - 1.5f*tileSize, posv.y-1) + backPosition;
								thing.transform.position  = hey;
								}
						}
				
						}
					}
				}
		


	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        		 LOAD PROPS
	public string LoadProps(){
		string line = file.Dequeue();
		int count = 1;
		while (line != null && !line[0].Equals (':')) {
			LoadOnMap(line, "Props");

		
			line = file.Dequeue();

				}
		return line;
		}


	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        		 GET TILE
												//3D coordinate to grid coord
	public Vector2 getTile(Vector3 m){
		int x_tile = (int)((m.x + x_center) / tileSize);
		int z_tile = (int)((m.z + z_center) / tileSize);
	//	Debug.Log ("x_center " + x_center + " tileSize " + tileSize);
		Vector2 me = new Vector2(x_tile, z_tile);
		//	Debug.Log ("FROM " + m + " TO " + me );
		return me;
	}
	

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       		 	IS LIT
	public bool isLit(Vector3 tile){	
		bool islit = false;

		GameObject[] light = GameObject.FindGameObjectsWithTag("PlayerLight");

		for (int i = 0; i<light.Length; ++i){
			Light l = light[0].GetComponentInChildren<Light>();
			if (l.type == LightType.Point){
				if (Vector3.Distance(l.transform.position, tile) <= l.range){
					islit = true;
				}
			}else if (l.type == LightType.Spot){
				float range = Mathf.Tan(l.spotAngle/2)*l.transform.localPosition.z;
				Vector3 loc = new Vector3(l.transform.position.x, 0,l.transform.position.z);
		//		Debug.Log("range is " + range + " loc is " + loc + " tile is " + tile);
				if (Vector3.Distance(loc, tile) <= range){
					islit = true;
				}
			}



		}
		return islit;
	}


	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        		CENTER OF TILE
												//3D coordinate to 3D coordinate
	public Vector3 CenterofTile(Vector3 m){
		int x_tile = (int)((m.x + x_center) / tileSize);
		int z_tile = (int)((m.z + z_center) / tileSize);

		Vector3 me = new Vector3(x_tile * tileSize - x_center + (tileSize / 2.0f) ,0.0f, z_tile * tileSize - z_center + (tileSize/2.0f));
	//	Debug.Log ("FROM " + m + " TO " + me);
		return me;
	}
	



	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       		 	LOAD TILES
	public string LoadTiles(){
	//{"key":"x","texture":"tilex"}
		string line = file.Dequeue();

		int count = 0;
		int count_g = 0;
		int count_w = 0;
		while (line != null &&  !line[0].Equals(':')){

			JSONParser p = new JSONParser (line);	
			p.parse();
			JSONObject k = new JSONObject();
			JSONObject v = new JSONObject();
			JSONObject g = new JSONObject();
			JSONObject mat = new JSONObject();
			string texture;
			string material;
			p.root.TryGetValue ("key", out k);
			line = file.Dequeue();
		//	Debug.Log("reading " + line);
			if (!p.root.TryGetValue ("texture", out v)){
				texture = "";
			}else { texture = v.value; }
			if (!p.root.TryGetValue ("material", out mat)){
				material = "";
			}else { material = mat.value;}
			subMesh m = new subMesh (texture, material,k.value[0]);

			if (p.root.TryGetValue ("iswall", out g)){
				m.id = count_w;
				wall.Add (k.value[0], m);
				count_w ++;
			}else if
			 (p.root.TryGetValue ("isgrid", out g)){
				m.id = count_g;
			//	Debug.Log(" added " + k.value[0]);
				grid.Add (k.value[0], m);
				count_g ++;
				if (k.value[0] == 'x'){
					m = new subMesh (texture,material, 's');
					m.id = count_g;
					grid.Add ('s', m);
					count_g ++;
				}
			}else{
				m.id = count;
			//	Debug.Log(" added " + k.value[0]);
				subs.Add (k.value[0], m);
				count ++;
			}

		}
		return line;
	}

	public string LoadCamera(string what){
		string line = file.Dequeue();
		while (line != null && !line[0].Equals (':')) {
			Central.Instance.LoadCameraStats (line);	
			line = file.Dequeue();
		}
		return line;
	
	}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        			LOAD ACTORS
	public string LoadActors(string what){
		string line = file.Dequeue();
		
		while (line != null && !line[0].Equals (':')) {
					
					
						actorStats actor =  Central.Instance.LoadActor (line);	
						LoadOnMap(line, what);
			line = file.Dequeue();
			//			Debug.Log("Loaded " + actor.name);
						if (what.Equals("Toys")){
							Peripheral.Instance.haveToys.Add(actor.name);
						}else{
							Peripheral.Instance.haveMonsters.Add(actor.name);
						}	
			}


				
			

		return line;
		}



	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        			LOAD MAP
	public string LoadMap(){
			int xtiles = 0;
			int ytiles = 0; 
			int wtf = 0;
		string line = file.Dequeue();
		map = new char[size_x, size_z];
			GRID = new char[size_x, size_z];
		
		while (line != null && !line[0].Equals (':')) {
						line.TrimEnd ('\r', '\n');
					//	Debug.Log(line);
						xtiles = line.Length;
								for (int c = 0; c < xtiles; c++) {
			//	Debug.Log(c + " " + ytiles + " " + size_x + " " + size_z);
										map[c,ytiles] = line [c]; 
										GRID[c,ytiles] = '.'; 
								}
								ytiles++;		
			line = file.Dequeue();
			//	size_x = xtiles;
					//	size_z = ytiles;
				}
			x_center = (float)size_x * tileSize / 2.0f;
			z_center =  size_z * tileSize / 2;
		visibleGRID = new char[GRID.GetLength (0), GRID.GetLength (1)];
		System.Array.Copy (GRID, visibleGRID, GRID.GetLength(0)*GRID.GetLength(1));
		
//		Debug.Log ("size_x " + size_x + " size_z " + size_z + " tileSize " + tileSize + " back " + tileSize * size_z / 2f);
		backPosition = new Vector3(0, tileSize * size_z / 2f, tileSize * size_z/2f);
		rightPosition = new Vector3(tileSize * size_x / 2f, tileSize * size_z / 2f,(size_z - size_x)*tileSize/2f);
		frontPosition = new Vector3 (0, tileSize * size_z / 2f, -tileSize * size_z / 2f);
		leftPosition = new Vector3 (-tileSize * size_x / 2f, tileSize * size_z / 2f, -(size_z - size_x) * tileSize / 2f);
		if (!test) {
						Eyes.Instance.PlaceCamera (size_x, size_z, tileSize);
				}
		return line;
	}

	public float diagonal(){
		return Mathf.Sqrt (size_x * size_x + size_z * size_z) * tileSize;
		}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      		  	MAKE SUB MESHES
//	makeSubMeshes (this.gameObject, subs, map);
	public void makeSubMeshes(GameObject what, Dictionary<char,subMesh> s,char[,] m){
		//add triangles by key
		MeshFilter mf = what.GetComponentInChildren<MeshFilter> ();
		foreach (KeyValuePair<char,subMesh> kvp in s) {
			(kvp.Value).Clear();
			}
		char k;
		int v1, v2, v3,v4,v5,v6 = 0;
		for (int r = 0; r < size_z; r++) {
			for (int c  = 0; c < size_x; c++) {
			//	Debug.Log("hey r "  + " " + c + " " + m [c,r]);
				k =  m [c,r];
				v1 = (size_x + 1) * r + c; //upper left
				v2 = (size_x + 1) * (r+1) + c; //bottom left
				v3 = (size_x + 1) * (r+1) + c + 1;  //bottom right
				v4 = (size_x + 1) * r + c;  //upper left
				v5 = (size_x + 1) * (r+1) + c + 1; //bottom right
				v6 = (size_x + 1) * r + c + 1; //upper right
		//		Debug.Log("K " + k);
				s[k].AddT(v1,v2,v3);
				s[k].AddT(v4,v5,v6);
			}
		}
		mf.mesh.subMeshCount = s.Count;

		foreach (KeyValuePair<char,subMesh> kvp in s) {
			mf.mesh.SetTriangles (((kvp.Value).getT ()).ToArray (), (kvp.Value).id);

		}
	}







	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	BUILD MESH
	public void BuildMesh(GameObject what, Dictionary<char,subMesh> s, int xsize, int zsize, int tile, bool collider){
		//Generate the mesh data
		Mesh m = new Mesh ();
		
		//float x_center = 0;
		//float y_center = 0;
		int vsize_x = xsize + 1;
		int vsize_z = zsize + 1;
		int numVerts = vsize_x * vsize_z;
		int numTiles = xsize * zsize;
		int numTris = numTiles * 2;
		vertices = new Vector3[numVerts];
		triangles = new int[numTris*3];
		normals = new Vector3[numVerts];
		uv = new Vector2[numVerts];
		
		
		//	Debug.Log ("HEY THERE");
		int x, z;
		for (z = 0; z < vsize_z; z++) {
			for (x = 0; x < vsize_x; x++) {
				vertices [z * vsize_x + x] = new Vector3 (x * tileSize - x_center,0, z * tileSize - z_center);
				//	Debug.Log("Coordinates: " +  x * tileSize + " " + y * tileSize);
				normals [z * vsize_x + x] = Vector3.up;
				//	Debug.Log("UV " + (y * vsize_x + x) + " X " + ((float)x /  vsize_x) + " Y " + ((float)y / vsize_y));
				uv [z * vsize_x + x] = new Vector2 ((float)x /  xsize, (float)z / zsize);
			}
		}
		for (z = 0; z < zsize; z++) {
			for (x = 0; x < xsize; x++) {
				int squareIndex = z*xsize + x;
				int triOffset = squareIndex * 6;
				triangles[triOffset + 0] = z * vsize_x + x +0;
				triangles[triOffset + 1] = z * vsize_x + x + vsize_x + 0;
				triangles[triOffset + 2] = z * vsize_x + x + vsize_x + 1;
				
				triangles[triOffset + 3] = z * vsize_x + x +0;
				triangles[triOffset + 5] = z * vsize_x + x + 1;
				triangles[triOffset + 4] = z * vsize_x + x + vsize_x + 1;
				
			}
		}
		
		//	Debug.Log ("SIZE IS " + size_x + " " + size_y);
		m.vertices = vertices;
		m.triangles = triangles;
		m.normals = normals;
		m.uv = uv;
		
		m.subMeshCount = xsize * zsize;
		
		
		MeshFilter mf = what.GetComponentInChildren<MeshFilter> ();
		MeshRenderer mr = what.GetComponentInChildren<MeshRenderer> ();

		mat = new Material[s.Count];
		
		foreach (KeyValuePair<char,subMesh> kvp in s) {
	
			mat[(kvp.Value).id] = loadMaterial(kvp.Value, xsize, zsize, tile);
		}
		mr.materials = mat;
		mf.mesh = m;
		if (collider) {
						BoxCollider c = what.GetComponent<BoxCollider> ();
						c.center = new Vector3(c.center.x,-tileSize/2,c.center.z);
						c.size = new Vector3 (xsize * tileSize, tileSize, zsize * tileSize);
				}
	}


	public Material loadMaterial(subMesh mesh, float xsize, float zsize, float tile){
		Material la;
		if (mesh.texture != ""){
			Texture2D tex = (Texture2D) Resources.Load("Surfaces/Map/" + mesh.texture, typeof(Texture2D));
			la = new Material(Shader.Find ("Transparent/Diffuse"));
			la.SetTexture("_MainTex", tex);		
		}else{
			la = (Material)Instantiate(Resources.Load("Surfaces/Map/" + mesh.material, typeof(Material)));
		}
		if (tile > 0){
			la.mainTextureScale = new Vector2(xsize/tile, zsize/tile);
		}else{
			la.mainTextureScale = new Vector2(1, 1);
		}
		la.name = char.ToString(mesh.key);
		return la;
	}
	
	
	//	BuildMesh (this.gameObject, subs, size_x, size_z,0);
	public void ConnectTiles(){
				//Generate the mesh data
		GameObject Path = (GameObject)Instantiate (Resources.Load ("Core/Path"));
		Path.transform.parent = this.gameObject.transform;

		Path.transform.position.Set (0, 1, 0);

		Mesh m = new Mesh ();
		//string[] path = level.Split('\\');
	//	string l = path[path.GetLength(0)-1];
		//string[] name = l.Split('.');
		GameObject waypath = (GameObject)Resources.Load ("Core/" + level + "_pathfinder");
		//Debug.Log ("Core/" + name[0] + "_pathfinder");
		List<WaypointNode> wps = new List<WaypointNode> (waypath.GetComponentsInChildren<WaypointNode> (true));
		wps.Sort (delegate(WaypointNode i1, WaypointNode i2) { 
			return i1.ID.CompareTo (i2.ID); 
		});

	
	

		int xsize = size_x;
		int zsize = size_z;
		int vsize_x = xsize + 1;
		int vsize_z = zsize + 1;
		
		//	int numTiles = ;
		int numTris = (wps.Count - 1)*2;
		int numVerts = numTris * 3;
		
		vertices = new Vector3[numVerts];
		triangles = new int[numTris*3];
		normals = new Vector3[numVerts];
		uv = new Vector2[numVerts];
	//	Debug.Log ("Path mesh has " + vertices + " vertices, " + triangles + " triangles, " + normals + " nornals, " + uv + "uvs\n");
		//Debug.Log
		int v = 0;
		int t = 0;


		foreach (WaypointNode w in wps) {
			foreach (WaypointNode n in w.neighbors) {
				//	Debug.Log(w.name + " " + n.name);
				if (w.name.CompareTo(n.name) < 0 && w.transform.position != n.transform.position){
				//	Debug.Log ("Connecting waypoint " + n.name + " and " + w.name);
					Vector2 start = getTile (CenterofTile(w.transform.position));
					Vector2 end = getTile (CenterofTile(n.transform.position));
					float xi = start.x;
					float zi = start.y;
					float xf = end.x;
					float zf = end.y;
					float dz = zf - zi;
					float dx = xf - xi;
					triangles [t++] = v;
					triangles [t++] = v + 1;
					triangles [t++] = v + 3;
					
					triangles [t++] = v;
					triangles [t++] = v + 3;
					triangles [t++] = v + 2;
				//	Debug.Log ("Start: " + start + " End: " + end + "\n");
					if (Mathf.Abs (dz / dx) > 1) {
						if (zf > zi) {
					//		Debug.Log("Taking lower 2 for " + n.name + " and upper 2 for " + w.name + "\n");
								//take lower 2 for f
								//take upper 2 for i							
							vertices [v++] = new Vector3 ((xf) * tileSize - x_center, 0, (zf+1) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xf + 1) * tileSize - x_center, 0, (zf+1) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi) * tileSize - x_center, 0, (zi) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi + 1) * tileSize - x_center, 0, (zi) * tileSize - z_center);
						} else {
								//take upper 2 for f
								//take lower 2 for i
							vertices [v++] = new Vector3 ((xf) * tileSize - x_center, 0, (zf + 1) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xf + 1) * tileSize - x_center, 0, (zf + 1) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi) * tileSize - x_center, 0, (zi) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi + 1) * tileSize - x_center, 0, (zi) * tileSize - z_center);
						}
					} else {
						if (xf > xi) {
								//take left 2 for f
								//take right 2 for i
							vertices [v++] = new Vector3 ((xf+1) * tileSize - x_center, 0, (zf) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xf+1) * tileSize - x_center, 0, (zf + 1) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi) * tileSize - x_center, 0, (zi) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi) * tileSize - x_center, 0, (zi + 1) * tileSize - z_center);
						} else {
								//take right 2 for f
								//take left 2 for i
							vertices [v++] = new Vector3 ((xf) * tileSize - x_center, 0, (zf) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xf) * tileSize - x_center, 0, (zf + 1) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi+1) * tileSize - x_center, 0, (zi) * tileSize - z_center);
							vertices [v++] = new Vector3 ((xi+1) * tileSize - x_center, 0, (zi + 1) * tileSize - z_center);
						}
				}
				}

			}
	
		}

		//there is something wrong with the normals or uvs or something, materials are not displaying,but I didn't care right now

		for (int i = 0; i < numVerts; i++) {
			normals [i] = Vector3.up;
			//	Debug.Log("UV " + (y * vsize_x + x) + " X " + ((float)x /  vsize_x) + " Y " + ((float)y / vsize_y));
			uv [i] = new Vector2 (vertices[i].x /(size_x*tileSize), vertices[i].z / (size_z*tileSize));
		}
		
		//	Debug.Log ("SIZE IS " + size_x + " " + size_y);
		m.vertices = vertices;
		m.triangles = triangles;
		m.normals = normals;
		m.uv = uv;
			
		
		MeshFilter mf = Path.GetComponent<MeshFilter> ();
		MeshRenderer mr = Path.GetComponent<MeshRenderer> ();

		mr.material = loadMaterial(subs['x'], size_x, size_z, 1);

		mf.mesh = m;

		
		MeshCollider c = Path.GetComponent<MeshCollider>();
		c.sharedMesh = m;
	
	}

	public float Distance(int xi, int yi, int xf, int yf){
		Vector2 i = new Vector2 (xi, yi);
		Vector2 f = new Vector2 (xf, yf);
		return Vector2.Distance (i, f);

	}




	public float PathNearby(int x, int y, int distance, float change, string factor){



		int min_x = Mathf.Max (0, x - distance);
		int min_y = Mathf.Max (0, y - distance);
		int max_x = Mathf.Min (map.GetLength(0)-1, x + distance);
		int max_y = Mathf.Min (map.GetLength(1)-1, y + distance);

		float sum = 0;
		for (int i = min_x; i <= max_x; i++) {
			for (int j = min_y; j <= max_y; j++) {

				if (map [i, j] == 'x') {
					switch (factor) {
					case "linear":
						sum += change;
						break;
					case "border":
						sum += (Distance(i,j, x,y)-distance/2f)*change;
						break;
					default:
						break;
					}



								}
						}
				}
		//Debug.Log (x + " " + y + " returned " + sum);
		return sum;
		}

	public void BlockBitsOfTheMap(){
	//	int start
		for (int i = 0; i < GRID.GetLength(0); i++) {
						for (int j = 0; j < GRID.GetLength(1); j++) {
								float empty = 0.90f;
								if (isOpen (new Vector2 (i, j))) {
										empty -= PathNearby(i,j,3,0.04f, "border");		
										float rightByPath = PathNearby (i,j,1,1,"linear");
					if (rightByPath > 0){empty = 1;}
										float roll = (float)Random.Range(0,1000)/1000f;															

										if (roll < empty) {									
												blockMe (i, j, 1, 1);
										}
								}

						}
				}


		}

	public void PlaceIslands(){
				char [,] ok = new char[GRID.GetLength(0),GRID.GetLength(1)];
				System.Array.Copy (GRID, ok, GRID.GetLength (0) * GRID.GetLength (1));

				for (int i = 0; i < ok.GetLength(0); i++) {
						for (int j = 0; j < ok.GetLength(1); j++) {
				//Debug.Log("Checking if " + i + " " + j + " is open");
								if (isOpen (i, j, 2, 2,ok)) {

									Vector2 pos = new Vector2(i,j);
									GameObject prop = PlaceObject ("square_island","Props",pos, new Vector3(2,2,2),false);

									prop.GetComponentInChildren<Island_Button>().size = 2;
									blockMe(i,j,2,2,ok);								
								}else{
									if (isOpen (i, j, 1, 1,ok)) {
							
										Vector2 pos = new Vector2(i,j);
										GameObject prop = PlaceObject ("square_island","Props",pos, new Vector3(1,1,1),false);

										prop.GetComponentInChildren<Island_Button>().size = 1;
										blockMe(i,j,1,1,ok);

									}
								}



						}
				}
		}
	public void MakeLotsofTinyPathColliders(){
		GameObject waypath = (GameObject)Resources.Load ("Core/" + level + "_pathfinder");
		List<WaypointNode> wps = new List<WaypointNode> (waypath.GetComponentsInChildren<WaypointNode> (true));
		wps.Sort (delegate(WaypointNode i1, WaypointNode i2) { 
			return i1.ID.CompareTo (i2.ID); 
		});

		int i = 0;
		
		foreach (WaypointNode w in wps) {
			foreach (WaypointNode n in w.neighbors) {
				//	Debug.Log(w.name + " " + n.name);
				if (w.name.CompareTo (n.name) < 0 && w.transform.position != n.transform.position) {
					//	Debug.Log ("Connecting waypoint " + n.name + " and " + w.name);
					string pp = "PathPartRound";
					GameObject Path = (GameObject)Instantiate (Resources.Load ("Core/"  + pp));
					Path.transform.parent = this.gameObject.transform;
					Path.name = pp + i;
					Path.transform.position.Set (0, -1, 0);
					Vector3 start = CenterofTile (w.transform.position);
					Vector3 end = CenterofTile (n.transform.position);
					float distance = Mathf.Abs(Vector3.Distance(start,end));

					float deltaZ = end.z - start.z;
					float deltaX = end.x - start.x;
					float angle = Mathf.Atan(deltaX/deltaZ)*180/Mathf.PI;				
			//		Debug.Log("DeltaX " + deltaX + " deltaX " + deltaX + " angle " + angle + "\n");

					Vector3 center = Vector3.Lerp (start, end, 0.5f);
					center = new Vector3(center.x, 0, center.z);
					Vector3 scale = new Vector3(1, 1, distance/tileSize + 1f);

					Vector3 rotation = new Vector3(0,angle,0);
					Path.transform.localScale = scale;	
					Path.transform.localPosition = center;
					Path.transform.localRotation = Quaternion.Euler(rotation);
										i++;
						
								}
						}
				}
		
	}

	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       				 CENTER OF OBJECT	
	//tile # to 3D coordinate
	public Vector3 CenterofObject(float x, float z, float xs, float zs){
		float x_min = 0f;
		float z_min = 0f;
		float x_max = 0f;
		float z_max = 0f;
		Vector2 tile = setObjectRange (x, z, xs, zs,ref x_min, ref z_min, ref x_max, ref z_max);
		Vector3 me = new Vector3(tile.x * tileSize - x_center + (tileSize / 2.0f) ,0.0f, tile.y * tileSize - z_center + (tileSize/2.0f));

		if (! isOpen(x,z,xs,zs)){
			return invalid;
		}

		return me;
	}
	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        	IS OPEN
	public bool isOpen(Vector2 t, char[,] matrix){
		//	Debug.Log ("open? " + t);
		return matrix[(int)t.x,(int)t.y].Equals('.');
	}

	public bool isOpen(Vector2 t){
		//	Debug.Log ("open? " + t);
		return isOpen (t, GRID);
	}

	public bool isOpen(float x, float z, float xs, float zs, char[,] matrix){

						float x_min = 0f;
						float z_min = 0f;
						float x_max = 0f;
						float z_max = 0f;
	

						Vector2 tile = setObjectRange (x, z, xs, zs, ref x_min, ref z_min, ref x_max, ref z_max);
						for (int i = (int)Mathf.Ceil(x_min); i <=(int)Mathf.Floor(x_max); i++) {
		
							for (int j = (int)Mathf.Ceil(z_min); j <=(int)Mathf.Floor(z_max); j++) {
								if (!isOpen(new Vector2(i,j),matrix)){
									return false;
								}
							}
						}
						return true;	
		}

	public bool isOpen(float x, float z, float xs, float zs){
		return isOpen (x, z, xs, zs, GRID);
	}


public Vector2 setObjectRange(float x, float z, float xs, float zs, ref float x_min, ref float z_min, ref float x_max, ref float z_max){
	float x_adj = 0;
	float z_adj = 0;
	if (Mathf.IsPowerOfTwo((int)xs) && xs > 1){ x_adj = 0.5f;}
	if (Mathf.IsPowerOfTwo((int)zs) && zs > 1){ z_adj = 0.5f;}
	
	float x_tile = x +  x_adj;
	float z_tile = z +  z_adj;
	
	x_min = x_tile - (xs / 2.0f);
	z_min = z_tile - (zs / 2.0f);
	if (x_min <= 0){x_tile -= x_min + 0.5f;}
	if (z_min <= 0){z_tile -= z_min + 0.5f;}
	
	x_max = x_tile + (xs / 2.0f);
	z_max = z_tile + (zs / 2.0f);
	if (x_max >= size_x){x_tile = size_x - (xs / 2.0f) - 0.5f;}// - x_adj;}
	if (z_max >= size_z){z_tile = size_z - (zs / 2.0f) - 0.5f;}// - z_adj;}

	x_min = (x_tile - (xs / 2.0f));
	z_min =(z_tile - (zs / 2.0f));
	x_max =(x_tile + (xs / 2.0f));
	z_max = (z_tile + (zs / 2.0f));

	return new Vector2(x_tile, z_tile);
}

public void blockMe(int x, int z, int xs, int zs){
	blockMe (x, z, xs, zs, GRID);
}

public void blockMe(int x, int z, int xs, int zs, char[,] matrix){
		float x_min = 0f;
		float z_min = 0f;
		float x_max = 0f;
		float z_max = 0f;
	Vector2 tile = setObjectRange (x, z, xs, zs, ref x_min, ref z_min, ref x_max, ref z_max);
	for (int i = (int)Mathf.Ceil(x_min); i <=(int)Mathf.Floor(x_max); i++) {
		for (int j = (int)Mathf.Ceil(z_min); j <=(int)Mathf.Floor(z_max); j++) {
			makeBlocked(i,j,matrix);
	//			Debug.Log("Blocking " + i + ", " + j + "\n");
		}
	}
}

	public void selectMe(int x, int z, int xs, int zs){
		float x_min = 0f;
		float z_min = 0f;
		float x_max = 0f;
		float z_max = 0f;
		Vector2 tile = setObjectRange (x, z, xs, zs, ref x_min, ref z_min, ref x_max, ref z_max);
		for (int i = (int)Mathf.Ceil(x_min); i <=(int)Mathf.Floor(x_max); i++) {
			for (int j = (int)Mathf.Ceil(z_min); j <=(int)Mathf.Floor(z_max); j++) {
				makeSelected(i,j);
		//		Debug.Log("Selecting " + i + ", " + j + "\n");
			}
		}
	}

}//end of class

public class actorStats{
	public string name;
	public List<int> cost = new List<int> ();
	public List<int> maxHP = new List<int> ();
	public List<int> dmg = new List<int> ();
	public string arrow;
	public int target = 0;
	public string team = "";
	public float range = 0;
	public bool areaEffect = false;
	public Vector3 scale = new Vector3 ();
	public int ammo = -1;
	public Dictionary<EffectType, Effect> inventory = new Dictionary<EffectType, Effect>();
	public Label info;

	public actorStats (string n, List<int> c, List<int> hp, List<int> d, string ar, float r, Vector3 sc){
		cost = c;
		maxHP = hp;
		name = n;
		dmg = d;
		scale = sc;
		arrow = ar;
		range = r;
		areaEffect = false;
		info = new Label (name);

	}

	public actorStats GetActorStats(){
		return this;
		}

	public void addEffect(Effect e){
		Effect have = null;
		inventory.TryGetValue(e.type, out have);
		if (have != null){
			inventory[e.type].strength += e.strength;
		}else{
			inventory.Add(e.type,e);
		}
	}

	public actorStats (){
		}
}

public class wave{
	public Queue<wavelet> wavelets = new Queue<wavelet> ();
	public float wait = 0f;
	public wave(){
	}

	public void add_wavelet(wavelet w){
		wavelets.Enqueue(w);
	}

	int calc_cheapest_monster(List<string> haveMonsters){
		actorStats max_monster = new actorStats();
		max_monster.cost.Add(9999);
		//haveMonsters = waves [i].monsters;
		
		//find the cheapest monster
		foreach (string m in haveMonsters) {
			if (max_monster.cost[0] > Central.Instance.actors [m].cost[0]) {
				max_monster = Central.Instance.actors [m];
			}
		}
		
		return max_monster.cost[0];
	}


	public wave(int n, List<string> m, float mi, float ll, int ws){
		//nightmares = n;
		//monsters = m;
		//monster_interval = mi;
		//lull_length = ll;
		int count = 0;

		//wavelet_size = ws;
		wavelet my_wavelet = new wavelet (mi, ll);
		while (n > calc_cheapest_monster(m)) {									
			while (count < ws){			
				int which = (int)Random.Range (0, m.Count);
				string monster = m[which];
				n -= Central.Instance.actors[monster].cost[0];
				my_wavelet.monsters.Enqueue(monster);
				count++;
			}
			wavelets.Enqueue(my_wavelet);
			my_wavelet = new wavelet(mi,ll);
			count = 0;
		}
	}
}


//{"mode":"list","1":{"monster_invertal":"0.5", "lull_length":"3","list":{"forceball,5,scaleball,3"}},"2":{"monster_invertal":"1", "lull_length":"5","list":{"speedball,1,drunkenbox,10,forceball"}},"3":{"monster_invertal":"0.5", "lull_length":"3","list":{"forceball,1,bigslidingbox,3"}}}
//{"mode":"random","nightmares":"50","monsters":"drunkenbox","monster_interval":"1","lull_length":"5","wavelet_size":"5"}
public class wavelet{
	public int nightmares;
	public Queue<string> monsters = new Queue<string>();
	public float monster_interval;
	public float lull_length;	
			
	public wavelet(float mi, float ll)
	{
		monster_interval = mi;
		lull_length = ll;
	}

	public wavelet(float mi, float ll, List<string> c)
	{
		monster_interval = mi;
		lull_length = ll;
		string monster = "";
		int count = 0;
		foreach (string m in c) 
		{

			if(int.TryParse(m, out count) || (!int.TryParse(m, out count) && monster != ""))
			{
				count = int.Parse(m);
			//	Debug.Log("Count is " + count);
				if(monster != "")
				{
					actorStats stats = null;
				 	if (Central.Instance.actors.TryGetValue(monster, out stats))
					{
						while(count > 0){
							monsters.Enqueue(monster);
				//			Debug.Log("Enqueueing " + monster);
							count--;
						}
						monster="";
					}
				}
			}else{
			//	Debug.Log("Monster is " + m);
				monster = m;
				count=1;
			}
		}

	//	Debug.Log ("Inside wavelet, wavelet has " + monsters.Count + " monsters");
	}



}



public class subMesh{
	public string texture;
	public string material;
	public char key;
	public int id;
	private List<int> triangles = new List<int>();

	public void Clear()
	{
		triangles.Clear ();
		}

	public void AddT(int one, int two, int three){
		triangles.Add (one);
		triangles.Add (two);
		triangles.Add (three);
		}

	public List<int> getT(){
		return triangles;
	
		}



	public subMesh(string t, string m, char k){
		texture = t;
		material = m;
		key = k;
	}
	}


